from classifiers.CNN import create_model
from classifiers.evaluation import predict
from etc.etc import read_file, read_files, accuracy
import argparse
from os import listdir
from os.path import join, isdir
from sklearn.model_selection import train_test_split
from sklearn.utils import shuffle
from sklearn.metrics import confusion_matrix, auc, roc_curve
from keras.utils import to_categorical
from numpy import array, arange, count_nonzero, argmax
from matplotlib import pyplot as plt
from PIL import Image

"""
File for Section Classification and Adversarial Variants of Section Classifiers

Section Classification (No Evaluation)
At Least One Classifier
Majority Vote Classifier
"""

MALWARE = 1
GOODWARE = 0

parser = argparse.ArgumentParser()

parser.add_argument("-g", "--goodware", default=None, required=True,
                    help="directory containing goodware file directories containing images")
parser.add_argument("-m", "--malware", default=None, required=True,
                    help="directory containing goodware file directories containing images")
parser.add_argument("-a", "--advars", default=None, required=True,
                    help="directory containing adversarial variant file directories containing images")
parser.add_argument("-i", "--infection", default="ApplySettingsTemplateCatalog.exe",
                    help="name of file the section was taken from that was used to infect the Malware, this name must match the directory name holding the section files")
parser.add_argument("-s", "--savemodel", default='.tmpfile',
                    help="file to save model")
parser.add_argument("-e", "--epochs", type=int, default=4,
                    help="epochs for CNN")
parser.add_argument("-r", "--results", default=None,
                    help="file to save model")

args = parser.parse_args()

# Read in directories containing files
goodware_directories = ([d for d in listdir(args.goodware) if isdir(join(args.goodware, d)) if d != args.infection])
malware_directories = ([d for d in listdir(args.malware) if isdir(join(args.malware, d))])
gwX_train, gwX_test, gwy_train, gwy_test = train_test_split(goodware_directories, (len(goodware_directories) * [GOODWARE]), test_size=0.2)
mwX_train, mwX_test, mwy_train, mwy_test = train_test_split(malware_directories, (len(malware_directories) * [MALWARE]), test_size=0.2)

# read in data from testing files to train the section classifier
gwX_train.append(args.infection)
gwX_train_imgs = read_files(gwX_train, args.goodware)
mwX_train_imgs = read_files(mwX_train, args.malware)
# normalize into 0 -> 1 values instead of RGB
imgs = array(gwX_train_imgs + mwX_train_imgs) / 255
# classification for the imgs
classifications = (len(gwX_train_imgs) * [GOODWARE]) + (len(mwX_train_imgs) * [MALWARE])
X_train, y_train = shuffle(imgs, classifications)
y_train = to_categorical(y_train)

# same as above, but for test data for the section classifier
gwX_test_imgs = read_files(gwX_test, args.goodware)
mwX_test_imgs = read_files(mwX_test, args.malware)
imgs = array(gwX_test_imgs + mwX_test_imgs) / 255
classifications = (len(gwX_test_imgs) * [GOODWARE]) + (len(mwX_test_imgs) * [MALWARE])
X_test, y_test = shuffle(imgs, classifications)
y_test = to_categorical(y_test)

# CREATE CNN MODEL
model = create_model(args.epochs, args.savemodel, X_train, y_train, X_test, y_test)

y_test = [ 1 if res[1] == 1 else 0 for res in y_test ]
y_pred = model.predict(X_test)
y_pred = [ argmax(y) for y in y_pred ]

# Sectino Confusion Matrix
tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
section_confusion_matrix = [ tp, fp, fn, tn ]

# get predictions on test data for mv and alo
alo_gw_predictions, mv_gw_predictions = predict(gwX_test, args.goodware, model)# , bias)
alo_mw_predictions, mv_mw_predictions = predict(mwX_test, args.malware, model)# , bias)

# ALO confusion Matrix
# tp, fp, fn, tn
alo_confusion_matrix = [
    alo_mw_predictions.count(MALWARE),
    alo_gw_predictions.count(MALWARE),
    alo_mw_predictions.count(GOODWARE),
    alo_gw_predictions.count(GOODWARE)
]

# MV Confusion Matrix
ttl_mw_count = len(mv_mw_predictions)
ttl_gw_count = len(mv_gw_predictions)

max_accuracy = 0
bias = 0
threshold = 0.0
mv_confusion_matrix = []

# find optimal threshold
for t in arange(0.0, 1.05, 0.05):
    tn = count_nonzero(mv_gw_predictions < t)
    tp = count_nonzero(mv_mw_predictions >= t)
    _accuracy = (tn+tp) / (ttl_gw_count + ttl_mw_count)

    if _accuracy > max_accuracy:
        max_accuracy = _accuracy
        threshold = t

tn = count_nonzero(mv_gw_predictions < threshold)
tp = count_nonzero(mv_mw_predictions >= threshold)
mv_confusion_matrix = [ tp, ttl_gw_count - tn, ttl_mw_count - tp, tn ]

# RESULTS
print("Majority Vote Accuracy: " + str(accuracy(mv_confusion_matrix)))
print("At Least One Accuracy: " + str(accuracy(alo_confusion_matrix)))
print("Section Accuracy (No Evaluation): " + str(accuracy(section_confusion_matrix)))

alo, mv = predict(mwX_test, args.advars, model)
mv_fn = count_nonzero(mv < threshold)
alo_fn = alo.count(GOODWARE)
print("Majority Vote False Negatives: " + str(float(mv_confusion_matrix[2])/float(len(mwX_test))))
print("Majority Vote Adversarial False Negatives: " + str(float(mv_fn)/float(len(mwX_test))))
print("At Least One False Negatives: " + str(float(alo_confusion_matrix[2])/float(len(mwX_test))))
print("At Least One Adversarial False Negatives: " + str(float(alo_fn)/float(len(mwX_test))))

#WRITE TO FILE
if args.results:
    results = [
        args.epochs,
        threshold,
        accuracy(section_confusion_matrix),
        section_confusion_matrix[0],
        section_confusion_matrix[1],
        section_confusion_matrix[2],
        section_confusion_matrix[3],
        accuracy(mv_confusion_matrix),
        mv_confusion_matrix[0],
        mv_confusion_matrix[1],
        mv_confusion_matrix[2],
        mv_confusion_matrix[3],
        accuracy(alo_confusion_matrix),
        alo_confusion_matrix[0],
        alo_confusion_matrix[1],
        alo_confusion_matrix[2],
        alo_confusion_matrix[3],
        mv_fn,
        alo_fn,
        len(mwX_test)
    ]
    f = open(args.results, "a")
    f.write("\n")
    f.write(', '.join([ str(res) for res in results ]))
    f.close()
