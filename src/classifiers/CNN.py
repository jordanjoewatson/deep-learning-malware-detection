from keras.utils import to_categorical
from keras.models import Sequential, Model, load_model
from keras.layers import Conv2D, MaxPool2D, LeakyReLU, Flatten,  Dense
from keras import layers
from keras.callbacks import EarlyStopping, ModelCheckpoint, Callback

"""
Creates the model structure for the Classification and Adversarial Variant
tasks. The model is similar in sizing to VGG-16 but reduced to 32x32
Images.
"""

def create_model(e, savemodel, X_train, y_train, X_test, y_test, outputs=2):
    """
    Creates the CNN Model used in the research

    Args:
        e (int): epochs to use for training
        savemodel (string): file to save the best model found through training
        X_train (array): training data array
        y_train (array): training results array
        X_test (array): testing data array
        y_test (array): testing results array
        outputs (int): amount of outputs for the results, e.g. 2 for binary classification

    Returns:
        Keras CNN Model
    """
    model = Sequential()
    model.add(Conv2D(64, kernel_size=(3,3), strides=(1,1),activation='linear',input_shape=(32,32,3),padding='same'))
    model.add(MaxPool2D((2,2),padding='same'))
    model.add(LeakyReLU(alpha=0.1))
    model.add(Conv2D(128, (3,3), strides=(1,1), activation='linear',padding='same'))
    model.add(MaxPool2D(pool_size=(2, 2),padding='same'))
    model.add(LeakyReLU(alpha=0.1))
    model.add(Conv2D(128, (3, 3), strides=(1,1), activation='linear',padding='same'))
    model.add(MaxPool2D(pool_size=(2, 2),padding='same'))
    model.add(LeakyReLU(alpha=0.1))
    model.add(Flatten())
    model.add(Dense(2048, activation='linear'))
    model.add(LeakyReLU(alpha=0.1))
    model.add(Dense(outputs, activation='softmax'))

    callbacks = [EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=40)]
    if savemodel:
        callbacks.append(ModelCheckpoint('{}'.format(savemodel), save_best_only=True, monitor='val_accuracy', mode='max'))

    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=e, callbacks=callbacks)
    model = load_model(savemodel)
    return model
